% To run this demon from matlab, type
%
% system_demo
%
fprintf('\f\nThis demonstration file shows some basic system routines\n');
fprintf('which are useful when playing with transfer functions,\n');
fprintf('including pole-zero determinations, impulse response\n');
fprintf('computation, and obtaining the autocorrelation sequence\n');
fprintf('corresponding to the filter.\n');
fprintf('The routines to be illustrated all use the normalized\n');
fprintf('lattice description.\n\n');
fprintf('(Hit any key to continue)\n\n');
pause
fprintf('We will generate randomly a 10th order transfer function,\n');
fprintf('using the commands\n\n');
fprintf('sth = 2.0*rand(1,10) - 1;\n');
fprintf('nu = [11:-1:1] .* (rand(1,11) - 0.5);\n');
fprintf('nu = nu/norm(nu);\n\n');
sth = 2.0*rand(1,10) - 1;
nu = [11:-1:1] .* (rand(1,11) - 0.5);
nu = nu/norm(nu);
fprintf('The first command set the reflection coefficients in vector sth\n');
fprintf('to numbers uniformly distributed between -1 and +1, so that\n');
fprintf('the filter is stable.\n');
fprintf('The tap coefficients, in vector nu, are also set to random\n');
fprintf('numbers. Since the L_2 norm of the transfer function is\n');
fprintf('norm(nu), scaling nu to unit norm gives a transfer function with\n');
fprintf('unit L_2 norm.\n\n');
fprintf('(Hit any key to continue)\n\n');
pause

fprintf('\f If you want the equivalent direct form filter coefficients,\n');
fprintf('you can type\n\n');
fprintf('[a,b] = lat2dir(nu,sth)\n\n');
fprintf('to generate the coefficients of the denominator in vector a,\n');
fprintf('and those of the numerator in vector b.\n');
fprintf('Direct form filters, though, can be quite sensitive to\n');
fprintf('small errors in the coefficients, and are known to be numerically\n');
fprintf('unreliable in many respects as far as filter realizations go.\n');
fprintf('Accordingly, all the routines in this demo never use the direct\n');
fprintf('form coefficients.\n\n');
fprintf('(Hit any key to continue)\n\n');
pause

fprintf('\f The poles and zeros of the filter can be computed from the \n');
fprintf('normalized lattice parameters using the LAT2PZ, as follows:\n\n');
fprintf('[pole,zero] = lat2pz(nu,sth);\n\n');
fprintf('The vector pole then contains the pole locations and the vector\n');
fprintf('zero contains the zero locations, both in the z^(-1) plane,\n');
fprintf('so that stable poles have moduli less than one.\n');
fprintf('The poles and zeros should now be plotted in\n');
fprintf('Figure 1.  Here is the largest pole radius:\n\n');
[pole,zero] = lat2pz(nu,sth);
format long;
radius_max = max(abs(pole))
figure(1)
clf
hold on
t = [0:0.01:2*pi];
if max(abs(zero)) > 1
 plot(zero,'o')
 axis('equal')
 plot(pole,'x')
 plot(cos(t),sin(t),'r')
else
 plot(cos(t),sin(t),'r')
 axis('equal')
 plot(zero,'o')
 plot(pole,'x')
end
hold off
title('Pole-Zero Plot')
xlabel('Real part')
ylabel('Imaginary part')
fprintf('\n(Hit any key to continue).\n\n');
himp = lat2imp(150,nu,sth);
pause

fprintf('\f The impulse response of the filter can be generated by using\n');
fprintf('the routine LAT2IMP.  To obtain the first 150 values, say,\n');
fprintf('you can type\n\n');
fprintf('himp = lat2imp(150,nu,sth);\n\n');
fprintf('The vector himp then contains the impulse response samples.\n');
fprintf('Figure 2 plots the impulse response for this example.\n\n');
figure(2)
plot([0:length(himp)-1],himp,'go')
hold on
title('Impulse Response')
xlabel('Index')
ylabel('Sample value')
xx = [1;1]*[0:length(himp)-1];
yy = [0; 1] * himp';
plot(xx,yy,'g')
hold off
pause

fprintf('Sometimes the autocorrelation sequence of the filter is required,\n');
fprintf('for, e.g., checking the autocorrelation sequence of a stochastic\n');
fprintf('process generated from the filter output, when the filter is\n');
fprintf('driven by unit variance white noise.\n');
fprintf('The routine LAT2COR can be used; the first 50 terms, say,\n');
fprintf('from the autocorrelation sequence can be generated by typing\n\n');
fprintf('rcor = lat2cor(50,nu,sth);\n\n');
fprintf('whose result is written to the vector rcor.\n');
fprintf('Figure 3 plots the autocorrelation sequence.\n\n');
rcor = lat2cor(50,nu,sth);
figure(3)
clf
plot([0:49],rcor,'bo')
hold on
title('Autocorrelation Sequence')
xlabel('Index')
ylabel('Lag value')
xx = [1;1]*[0:length(rcor)-1];
yy = [0; 1] * rcor';
plot(xx,yy,'b')
hold off
fprintf('\n(Hit any key to continue).\n\n')
pause


fprintf('Computing autocorrelation sequences can sometimes be tricky.\n');
fprintf('The Toeplitz matrix built from any autocorrelation sequence\n');
fprintf('is theoretically positive (semi-) definite, but small numerical\n');
fprintf('errors in the computed autocorrelation sequence can sometimes\n');
fprintf('destroy this property, particularly if the sequence originates\n');
fprintf('from a filter with poles quite close to the unit circle.\n');
fprintf('To check whether the computed sequence is indeed an\n');
fprintf('autocorrelation sequence, we can type\n\n');
fprintf('eigvals = eig(toeplitz(rcor));\n\n');
fprintf('to examine whether the (computed) eigenvalues of this 50-by-50\n');
fprintf('matrix are all positive.\n');
fprintf('Hit any key to see the result for this example.\n');
eigvals = sort(eig(toeplitz(rcor)));
kk = length(eigvals);
pause
figure(4)
semilogy(eigvals(kk:-1:1))
title('Eigenvalues of Autocorrelation Matrix')
xlabel('Index')
ylabel('Eigenvalue')
%
% Clear registers
%
clear eigvals nu rcor zero himp pole sth kk radius_max t xx yy
%end of system_demo
%
% Last modified: March 1997, Phil Regalia